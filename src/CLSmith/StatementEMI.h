// Statement that represents a section of code that will be used for EMI
// (Equivalence Modulo Input) testing. These sections will be dead by
// construction, and so will never be executed. To prevent the compiler from
// statically determining that the code is dead, the test expression controlling
// access will use data initialised by the host.
// 
// Once the program has been generated, an EMI variant of the program will be
// generated by pruning the EMI sections according to three probabilities:
// - p_compound: Probability of deleting a compound statement (if, for, ...).
// - p_leaf: Probability of deleting a simple statement (assign, break, ...).
// - p_lift: Probability of lifting the body of a compound statement up one
//   level to the parent block (if (...) {x = y; break;} -> x=y; break;).

#ifndef _CLSMITH_STATEMENTEMI_H_
#define _CLSMITH_STATEMENTEMI_H_

#include <memory>
#include <ostream>
#include <vector>

#include "CGContext.h"
#include "CLSmith/CLStatement.h"
#include "CLSmith/MemoryBuffer.h"
#include "CommonMacros.h"
#include "StatementIf.h"

class Block;
class FactMgr;

namespace CLSmith {

// Compound statement for an EMI section of code.
// Basically just wraps around a StatementIf. Will handle pruning itself.
class StatementEMI : public CLStatement {
 public:
  StatementEMI(Block *parent, StatementIf *if_block)
      : CLStatement(kEMI, parent), if_block_(if_block) {
  }
  StatementEMI(StatementEMI&& other) = default;
  StatementEMI& operator=(StatementEMI&& other) = default;
  virtual ~StatementEMI() {}

  // Factory method for creating an EMI block. This will just be the same as
  // creating a random StatementIf, but with more control over the test
  // expression.
  static StatementEMI *make_random(CGContext& cg_context);

  // Remove statements from the block according to the three probabilities
  // outlined at the top.
  void Prune();

  // Pure virtual in Statement. Not really needed.
  void get_blocks(std::vector<const Block *>& blks) const {
    if_block_->get_blocks(blks);
  }
  void get_exprs(std::vector<const Expression *>& exps) const {
    if_block_->get_exprs(exps);
  }

  // Outputs the EMI block. Nothing special required, delegate to StatementIf.
  void Output(std::ostream& out, FactMgr *fm, int indent) const {
    if_block_->Output(out, fm, indent);
  }

 private:
  // Prune helper function. Pruning is performed recursively, calling this
  // function each time a block is entered.
  void PruneBlock(Block *block);

  // Helper for PruneBlock. Merge the second block into the first, invalidating
  // the second block. Position specifies where the statements are inserted,
  // returns an iterator to the last statement.
  std::vector<Statement *>::iterator MergeBlock(
      std::vector<Statement *>::iterator position, Block *former, Block *merger);
  // TEMP helper for prune that removes conts and breaks from nested blocks.
  // Will remove when I get around to fixing the walker.
  void RemoveBreakContinue(Block *block);

  // If statement being wrapped.
  std::unique_ptr<StatementIf> if_block_;

  DISALLOW_COPY_AND_ASSIGN(StatementEMI);
};

// Collects each EMI instance, and handles the input data required by each
// instance.
class EMIController {
 public:
  explicit EMIController(MemoryBuffer *emi_input)
      : emi_input_(emi_input), itemised_emi_input_({emi_input}) {
  }
  EMIController(EMIController&& other) = default;
  EMIController& operator=(EMIController&& other) = default;
  virtual ~EMIController() {}

  // Accessors for a singleton instance of the controller. The instance will be
  // created lazily.
  static EMIController *GetEMIController();
  static void ReleaseEMIController();

  // Factory for creating a controller. Will create a memory buffer.
  static EMIController *CreateEMIController();

  // Add an emi section that will later be pruned.
  void AddStatementEMI(StatementEMI *emi) { emi_sections_.push_back(emi); }

  // Remove an emi section. It is down to the Statement EMI to remove itself
  // from the controller. Returns true if something was removed.
  bool RemoveStatementEMI(StatementEMI *emi);

  // Add an itemised reference to the emi inpu data.
  void AddItemisedEMIInput(MemoryBuffer *item);

  // Performs pruning on all EMI sections that have been added to the
  // controller. This should be done as a post-process, after the program has
  // been completely generated.
  void PruneEMISections();

  // Get the memory buffer that holds the data used for the test expressions.
  MemoryBuffer *GetEMIInput() { return emi_input_.get(); }
  // Get the vector of all references to the emi input.
  std::vector<MemoryBuffer *> *GetItemisedEMIInput() {
    return &itemised_emi_input_;
  }

 private:
  // All StatementEMIs are collected here. (Should probably use a list)
  std::vector<StatementEMI *> emi_sections_;
  // Input data for the test expressions.
  std::unique_ptr<MemoryBuffer> emi_input_;
  std::vector<MemoryBuffer *> itemised_emi_input_;

  DISALLOW_COPY_AND_ASSIGN(EMIController);
};

}  // namespace CLSmith

#endif  // _CLSMITH_STATEMENTEMI_H_
